---
title: "PGY2 Solve - Allocations 2024"
author: "Dr Scott Johnson Gelzinnis"
date: "`r Sys.Date()`"
output:
  html_notebook:
    theme: journal
    df_print: paged
  html_document:
    theme: journal
    df_print: paged
  pdf_document: default
---

*Copyright Dr Scott Johnson Gelzinnis (2023) - Statement below*


  
# Setting up the Environment  


```{r include=TRUE, echo=TRUE, results='hide'}
library(here)
i_am("PGY2_Solve.Rmd")

# List of required packages
required_packages <- c(
  "randomNames", "lpSolve", "lpSolveAPI", "ROI", "gt", 
  "readr", "tidyverse", "googlesheets4", "stringr", "knitr",
  "janitor"
)

# Install and load packages using tidyverse-style code
required_packages %>%
  setdiff(installed.packages()[,"Package"]) %>%
  walk(install.packages)

# Load the packages
purrr::walk(required_packages, library, character.only = TRUE)

# Random seed
set.seed(69)
```



# Loading in the Preference Matrix 

```{r include=TRUE, echo=TRUE, results='hide'}
# Read in Google Sheet
raw_preference_data <- read_sheet("https://docs.google.com/spreadsheets/d/1JW_KriVymSe9NNVi1QjKnshoWrkAhZ8FkKzpqXy1bf8/edit?usp=sharing")

## Define preference matrix ##

# Transform the data
preference_data <- raw_preference_data %>%
  # Combine columns first name and last name to create the "Doctor" column
  mutate(Doctor = paste(.[[13]], .[[14]], sep = ", ")) %>%
  # Extract columns that match the pattern '| '
  select(Doctor, matches("\\| ")) %>%
  # Clean the column names
  rename_with(~gsub(".*\\| ", "", .x))

# Convert to matrix
preference_matrix <- as.matrix(preference_data[, -1])

# Set "Doctor" column as row names
rownames(preference_matrix) <- preference_data$Doctor

# Define dimensions based on preference_matrix
num_columns <- ncol(preference_matrix)
num_doctors <- nrow(preference_matrix)
num_terms <- num_columns  # Assuming the number of terms is equal to the number of columns in the matrix
row_names <- rownames(preference_matrix)
column_names <- colnames(preference_matrix)
```


# Definitions

```{r include=TRUE, echo=TRUE, results='hide'}
## Linear Optimization - Defining the problem ##
# Read in the CSV only once
df <- read_csv("PGY2 2024.csv")

# Define the number of doctors and terms (already defined in previous code, no need to redefine)
# num_doctors <- nrow(preference_matrix)
# num_terms <- ncol(preference_matrix)

# Define the objective function coefficients (preferences) (already defined in previous code)
# objective_coeffs <- as.vector(preference_matrix)

# Extract vectors from the already loaded dataframe
max_doctors_per_term1 <- as.vector(df$X2[-1])
max_doctors_per_term2 <- as.vector(df$X3[-1])
max_doctors_per_term3 <- as.vector(df$X4[-1])
max_doctors_per_term4 <- as.vector(df$X5[-1])
max_doctors_per_term5 <- as.vector(df$X6[-1])

clinical_structure_term <- as.vector(df$X11[-1])
names(clinical_structure_term) <- df[[1]][-1]

specialty_status_per_term <- as.factor(df$X9[-1])
sub_specialty_status_per_term <- as.factor(df$X10[-1])
rural_status_term <- as.factor(df$X12[-1])

term_classification1 <- as.factor(df$`Term Classification`)
term_classification2 <- as.factor(df$`Term Classification 2`)

```



# Linear Optimization Model with Minimized Dissatisfaction

### With allowable constraints to provide viable solution (i.e if unable to solve, roll back constraint one at a time)

```{r include=TRUE, echo=TRUE, results='hide'}
# Load necessary libraries
library(gt)
library(lpSolve)

# Read the CSV data
data <- read.csv("doctor_preferences.csv")

# Extract necessary columns
doctor_names <- data$Doctor_Name
specialty_status_per_term <- data$Specialty_Status_per_Term
sub_specialty_status_per_term <- data$Sub_Specialty_Status_per_Term
preference_matrix <- data[, 3:7] # Modify if the columns are different

# Define variables
num_doctors <- nrow(data)
num_terms <- 5
row_names <- doctor_names
column_names <- c("Term1", "Term2", "Term3", "Term4", "Term5")

# Directly use preference_matrix as dissatisfaction values
dissatisfaction_values <- preference_matrix
objective_coeffs_dissatisfaction <- as.vector(dissatisfaction_values)

# Initialize variables for the loop
num_assignments <- 5
assignment_results <- list()
assigned_terms_matrix <- matrix(0, nrow = num_doctors, ncol = num_terms)

# The main loop for assignments
for (assignment_num in 1:num_assignments) {
  
  # Linear Programming setup
  lp_model_dissatisfaction <- make.lp(0, num_doctors * num_terms)
  set.type(lp_model_dissatisfaction, columns = 1:(num_doctors * num_terms), type = "binary")
  set.objfn(lp_model_dissatisfaction, objective_coeffs_dissatisfaction)
  
  # ... [Constraints and other setups] ...
  
  # Solve the LP model
  lp_result_dissatisfaction <- solve(lp_model_dissatisfaction)
  
  # Check results
  if (lp_result_dissatisfaction == 0) {
    optimal_solution_dissatisfaction <- get.variables(lp_model_dissatisfaction)
    assignment_results[[assignment_num]] <- optimal_solution_dissatisfaction
    
    # Update assignments
    for (i in 1:num_doctors) {
      for (j in 1:num_terms) {
        if (optimal_solution_dissatisfaction[(i - 1) * num_terms + j] == 1) {
          assigned_terms_matrix[i, j] <- 1
        }
      }
    }
  } else {
    cat("Issue with assignment", assignment_num, ". Result:", lp_result_dissatisfaction, "\n")
  }
}

# Display status
status_code <- lp_result_dissatisfaction
status_explanation <- switch(as.character(status_code),
                             "0" = "Optimal solution achieved",
                             "1" = "Solver ran out of memory",
                             "2" = "Problem is infeasible",
                             "3" = "Problem is unbounded",
                             "4" = "Feasible solution found",
                             "5" = "Problem is degenerate",
                             "6" = "Timeout reached",
                             "Unknown status")
cat("Status code:", status_code, "\n")
cat("Explanation:", status_explanation, "\n")

# Display assignment results
for (assignment_num in 1:num_assignments) {
  cat("Assignment", assignment_num, "results:\n")
  optimal_solution_dissatisfaction <- assignment_results[[assignment_num]]
  for (i in 1:num_doctors) {
    for (j in 1:num_terms) {
      if (optimal_solution_dissatisfaction[(i - 1) * num_terms + j] == 1) {
        doctor_name <- row_names[i]
        term_name <- column_names[j]
        cat("Doctor", doctor_name, "is assigned to", term_name, "\n")
      }
    }
  }
  cat("\n")
}

# Tabulate the assignments
assignment_table <- data.frame(Doctor = row_names, 
                               Assignment1 = character(num_doctors), 
                               Assignment2 = character(num_doctors),
                               Assignment3 = character(num_doctors),
                               Assignment4 = character(num_doctors),
                               Assignment5 = character(num_doctors),
                               stringsAsFactors = FALSE)

for (assignment_num in 1:num_assignments) {
  optimal_solution_dissatisfaction <- assignment_results[[assignment_num]]
  for (i in 1:num_doctors) {
    for (j in 1:num_terms) {
      if (optimal_solution_dissatisfaction[(i - 1) * num_terms + j] == 1) {
        term_name <- column_names[j]
        assignment_column <- paste0("Assignment", assignment_num)
        assignment_table[i, assignment_column] <- term_name
      }
    }
  }
}

# Print the table
gt_table <- gt(assignment_table)
print(gt_table)
```



# PGY2 Unassigned terms

```{r include=TRUE, echo=TRUE, results='markup'}

```


# MODEL EVALUATION

### This will be used when real data is available to play with quadratic penalties, iterative penalties to the dissatisfaction values in order give higher prioritization to Top 10 preferences over a generally good spread of preferences. 3 working models currently at present.

```{r include=TRUE, echo=TRUE, results='markup'}
# Convert the preference matrix into a top 10 boolean matrix
top_10_matrix <- preference_matrix %>%
  apply(1, function(row) row %in% sort(row, decreasing = FALSE)[1:10]) %>%
  t() # Transpose the result to match original shape

# Convert the preference matrix into a top 5 boolean matrix
top_5_matrix <- preference_matrix %>%
  apply(1, function(row) row %in% sort(row, decreasing = FALSE)[1:5]) %>%
  t()

# Define a function to extract metrics for assignments based on a given matrix
get_metrics <- function(matrix, assignment_df) {
  map2_dbl(1:num_assignments, names(assignment_df)[2:(num_assignments + 1)], 
          ~ {
            # For each assignment, retrieve the assigned terms
            assigned_terms <- assignment_df[[.y]]
            
            # Convert term names to their column indices
            assigned_indices <- match(assigned_terms, colnames(selected_data))
            
            # Sum the values from the matrix based on the assigned indices
            sum(matrix[cbind(1:num_doctors, assigned_indices)])
          })
}

# Get the count of terms in top 10 and top 5 for each doctor and assignment
top_10_counts_per_doctor <- get_metrics(top_10_matrix, assignment_table)
top_5_counts_per_doctor <- get_metrics(top_5_matrix, assignment_table)

# Extract preference values for all assigned terms for each doctor across all assignments
assigned_preference_values <- map2_df(1:num_assignments, names(assignment_table)[2:(num_assignments + 1)], 
                                     ~ {
                                       assigned_terms <- assignment_table[[.y]]
                                       assigned_indices <- match(assigned_terms, colnames(selected_data))
                                       
                                       # Extract preference values from the preference matrix
                                       preference_matrix[cbind(1:num_doctors, assigned_indices)]
                                     })

# Create a tibble for evaluation metrics, calculating each metric as required
evaluation_data <- tibble(
  Metric = c("At least 1 term in Top 10 (%)", 
             "At least 2 terms in Top 10 (%)", 
             "At least 3 terms in Top 10 (%)", 
             "At least 1 term in Top 5 (%)",
             "Average Preference of Assigned Terms",
             "Average Max of Assigned Preferences",
             "Average Min of Assigned Preferences",
             "Average SD of Assigned Preferences"),
  Value = c(
    mean(top_10_counts_per_doctor > 0) * 100,  # Percentage of doctors with at least 1 term in top 10
    mean(top_10_counts_per_doctor >= 2) * 100, # ... with at least 2 terms in top 10
    mean(top_10_counts_per_doctor >= 3) * 100, # ... with at least 3 terms in top 10
    mean(top_5_counts_per_doctor > 0) * 100,   # Percentage of doctors with at least 1 term in top 5
    mean(as.vector(assigned_preference_values)),        # Average preference value of all assigned terms
    mean(apply(assigned_preference_values, 1, max)),    # Average of maximum preference values per doctor
    mean(apply(assigned_preference_values, 1, min)),    # Average of minimum preference values per doctor
    mean(apply(assigned_preference_values, 1, sd))      # Average standard deviation of preference values per doctor
  )
) %>%
  mutate(Value = round(Value, 2)) # Round values to two decimal places

# Create and format a table using gt to display the evaluation metrics
evaluation_table <- gt(evaluation_data) %>% 
  tab_header(
    title = "Model Evaluation"
  ) %>%
  cols_label(
    Metric = "Metric",
    Value = "Value"
  )

# Output the table
evaluation_table
```


                         
# Reporting - 

### To add transparancy to allocations process and to assist in manual auditing of lines in order to preserve the integrity of the preferences of the cohort. Assist with manual changes to make terms HETI compliant or understand GAPS in the event their is nil viable solution to whole gamut of constraints. 

```{r include=TRUE, echo=TRUE, results='markup'}
# 1. Doctors Preference Report

# Initialize an empty data frame to store the report
doctor_preference_report <- data.frame(
  Doctor = character(),
  Term = character(),
  Preference_Score = numeric(),
  stringsAsFactors = FALSE
)

# Iterate through each doctor
for (i in 1:num_doctors) {
  doctor_name <- row_names[i]
  
  # Iterate through each of the assignments to extract the allocated terms for each doctor
  for (assignment_num in 1:num_assignments) {
    optimal_solution_dissatisfaction <- assignment_results[[assignment_num]]
    for (j in 1:num_terms) {
      if (optimal_solution_dissatisfaction[(i - 1) * num_terms + j] == 1) {
        assigned_term <- column_names[j]
        
        # Access the doctor's preference row from the preference matrix
        doctor_preference <- preference_matrix[i, ]
        
        # Calculate preference score for the assigned term
        preference_score <- doctor_preference[match(assigned_term, column_names)]
        
        # Build a data frame with the results for this doctor and term
        doctor_report <- data.frame(
          Doctor = rep(doctor_name, 1),
          Term = assigned_term,
          Preference_Score = preference_score
        )
        
        # Append the doctor's report to the overall report data frame
        doctor_preference_report <- rbind(doctor_preference_report, doctor_report)
      }
    }
  }
}


gt(doctor_preference_report)
```


```{r include=TRUE, echo=TRUE, results='markup'}
# 2. HETI Compliance Report


# Calculate average preference for each doctor across all 5 assignments
avg_preference <- doctor_preference_report %>%
  group_by(Doctor) %>%
  summarize(Avg_Score = mean(Preference_Score, na.rm = TRUE))

# Check if a doctor has been assigned to more than 1 term in any sub-specialty
sub_specialty_compliance <- sapply(1:num_doctors, function(i) {
  doctor_name <- row_names[i]
  assigned_terms_df <- subset(doctor_preference_report, Doctor == doctor_name)
  terms_assigned <- assigned_terms_df$Term
  sub_specialty_terms <- sub_specialty_status_per_term[terms_assigned]
  max_count <- max(table(sub_specialty_terms), na.rm = TRUE)
  return(max_count <= 1)
})

# Check if a doctor has been assigned to more than 2 terms in any specialty
specialty_compliance <- sapply(1:num_doctors, function(i) {
  doctor_name <- row_names[i]
  terms_assigned <- doctor_preference_report$Term[doctor_preference_report$Doctor == doctor_name]
  specialty_terms <- specialty_status_per_term[terms_assigned]
  max_count <- max(table(specialty_terms), na.rm = TRUE)
  return(max_count <= 2)
})

# Check if a doctor has been assigned to at least 3 "Team Based" terms
team_based_compliance <- sapply(1:num_doctors, function(i) {
  doctor_name <- row_names[i]
  terms_assigned <- doctor_preference_report$Term[doctor_preference_report$Doctor == doctor_name]
  
  # Debugging print statements
  print(paste("Doctor:", doctor_name))
  print(paste("Assigned terms:", toString(terms_assigned)))
  structure_indices <- match(terms_assigned, names(clinical_structure_term))
  print(paste("Matching indices:", toString(structure_indices)))
  print(paste("Clinical structures:", toString(clinical_structure_term[structure_indices])))
  
  team_based_count <- sum(clinical_structure_term[structure_indices] == "Team Based")
  
  return(team_based_count >= 3)
})

# Check for compliance with the desired term classifications
check_term_classifications <- function(terms_assigned) {
  classification1 <- term_classification1[match(terms_assigned, column_names)]
  classification2 <- term_classification2[match(terms_assigned, column_names)]
  required_terms <- c("A-Undifferentiated illness patient care", 
                      "B-Chronic illness patient care", 
                      "C-Acute critical illness patient care")
  
  # Check for each term individually, without merging the classifications
  has_required_terms <- sapply(required_terms, function(term) {
    term %in% classification1 || term %in% classification2
  })
  
  return(all(has_required_terms))
}

term_classifications_compliance <- sapply(1:num_doctors, function(i) {
  doctor_name <- row_names[i]
  terms_assigned <- doctor_preference_report$Term[doctor_preference_report$Doctor == doctor_name]
  return(check_term_classifications(terms_assigned))
})

compliance_data <- data.frame(
  Doctor = avg_preference$Doctor,
  Avg_Preference = avg_preference$Avg_Score,
  SubSpecialty_Compliance = sub_specialty_compliance,
  Specialty_Compliance = specialty_compliance,
  Team_Based_Compliance = team_based_compliance,
  Term_Classifications_Compliance = term_classifications_compliance
)

# Format with gt

HETI_compliance_table <- compliance_data %>%
  gt() %>%
  cols_label(
    Avg_Preference = "Avg. Preference (1-5)",
    SubSpecialty_Compliance = "Max 1 Term in Sub-Specialty",
    Specialty_Compliance = "Max 2 Terms in Specialty",
    Team_Based_Compliance = "At Least 3 'Team Based' Terms",
    Term_Classifications_Compliance = "Essential Classifications"
  )

print(HETI_compliance_table)
```



*This code, inclusive of all associated documentation and related content, is the exclusive intellectual property of Dr. Scott Johnson Gelzinnis under the Copyright Act 1968 (Cth) of Australia. Any unauthorized use, reproduction, distribution, or modification of this material, in entirety or in parts, without the prior written consent of Dr. Scott Johnson Gelzinnis, may constitute a breach of Australian copyright laws and can result in legal action.*
