---
title: "PGY2 Solve - Allocations 2024"
author: "Dr Scott Johnson Gelzinnis"
date: "`r Sys.Date()`"
output:
  html_notebook:
    theme: journal
    df_print: paged
  html_document:
    theme: journal
    df_print: paged
  pdf_document: default
---

*Copyright Dr Scott Johnson Gelzinnis (2023) - Statement below*


  
# Setting up the Environment  


```{r include=TRUE, echo=TRUE, results='hide'}
library(here())
i_am("PGY2_Solve.Rmd")

#Set WD
# setwd("D:/My Documents/GitHub/term-allocations")

# List of required packages
required_packages <- c("randomNames", "lpSolve", "lpSolveAPI", "ROI", "gt", "readr", "tidyverse", "googlesheets4", "stringr")

# Check if packages are installed and install them if they are not
new_packages <- required_packages[!(required_packages %in% installed.packages()[,"Package"])]
if(length(new_packages)) install.packages(new_packages)

# Load the packages
lapply(required_packages, require, character.only = TRUE)

# Random seed
set.seed(69)

```



# Loading in the Preference Matrix 

```{r include=TRUE, echo=TRUE, results='hide'}

## Read in Google Sheet
raw_preference_data <- read_sheet("https://docs.google.com/spreadsheets/d/1JW_KriVymSe9NNVi1QjKnshoWrkAhZ8FkKzpqXy1bf8/edit?usp=sharing")


                        ## Define preference matrix  ##

# Combine columns 13 and 14 to create the "Doctor" column
raw_preference_data$Doctor <- paste(raw_preference_data[[13]], raw_preference_data[[14]], sep = ", ")

# Adjust the term extraction to account for the '| ' at the beginning
unique_terms <- unique(str_extract(names(raw_preference_data), "(?<=\\| ).+"))
unique_terms <- unique_terms[!is.na(unique_terms)]

# Rename the columns to keep only the term names after '| ' (i.e., pipe followed by a space)
colnames(raw_preference_data) <- ifelse(grepl("\\| ", names(raw_preference_data)),
                                        str_extract(names(raw_preference_data), "(?<=\\| ).+"),
                                        names(raw_preference_data))

# Now, select relevant columns
selected_data <- raw_preference_data %>%
  select(Doctor, all_of(unique_terms))

# Verify if the selection is successful
head(selected_data)

# Reshaping the data
preference_matrix <- selected_data %>%
  pivot_longer(cols = -Doctor, names_to = "Term", values_to = "Preference") %>%
  spread(key = "Term", value = "Preference")


                        ## Linear Optimization - Defining the problem ##

df <- read_csv("PGY2 Solve.csv")

# Define the number of doctors and terms
num_doctors <- nrow(preference_matrix)
num_terms <- ncol(preference_matrix)

# Define the objective function coefficients (preferences)
objective_coeffs <- as.vector(preference_matrix)

#Create a vector of the maximum number of doctors allowed for Term 1
max_doctors_per_term1 <- read_csv("PGY2 Solve.csv", col_names = FALSE, skip = 1)
max_doctors_per_term1 <- as.vector(max_doctors_per_term1$X3)

#Create a vector of the maximum number of doctors allowed for Term 2
max_doctors_per_term2 <- read_csv("PGY2 Solve.csv", col_names = FALSE, skip = 1)
max_doctors_per_term2 <- as.vector(max_doctors_per_term2$X4)

#Create a vector of the maximum number of doctors allowed for Term 3
max_doctors_per_term3 <- read_csv("PGY2 Solve.csv", col_names = FALSE, skip = 1)
max_doctors_per_term3 <- as.vector(max_doctors_per_term3$X5)

#Create a vector of the maximum number of doctors allowed for Term 4
max_doctors_per_term4 <- read_csv("PGY2 Solve.csv", col_names = FALSE, skip = 1)
max_doctors_per_term4 <- as.vector(max_doctors_per_term4$X6)

#Create a vector of the maximum number of doctors allowed for Term 5
max_doctors_per_term5 <- read_csv("PGY2 Solve.csv", col_names = FALSE, skip = 1)
max_doctors_per_term5 <- as.vector(max_doctors_per_term5$X7)

#Create a vector that describes the Clinical Team structure of a term
clinical_structure_term <- read_csv("PGY2 Solve.csv", col_names = FALSE, skip = 1)
clinical_structure_term <- as.vector(clinical_structure_term$X13)
names(clinical_structure_term) <- df[[1]]


#Create a vector that describes "Specialty" status of a term
specialty_status_per_term <- read_csv("PGY2 Solve.csv", col_names = FALSE, skip = 1)
specialty_status_per_term <- as.vector(specialty_status_per_term$X8)
specialty_status_per_term <- as.factor(specialty_status_per_term)

#Create a vector that describes "Sub-Specialty" status of a term
sub_specialty_status_per_term <- read_csv("PGY2 Solve.csv", col_names = FALSE, skip = 1)
sub_specialty_status_per_term <- as.vector(sub_specialty_status_per_term$X9)
sub_specialty_status_per_term <- as.factor(sub_specialty_status_per_term)

#Create a vector that describes "Term Classification 1" of a term
term_classification1 <- df$`Term Classification`
term_classification1 <- as_factor(term_classification1)


#Create a vector that describes "Term Classification 2" of a term
term_classification2 <- df$`Term Classification 2`
term_classification2 <- as_factor(term_classification2)

```



# Linear Optimization Model with Minimized Dissatisfaction

### With allowable constraints to provide viable solution (i.e if unable to solve, roll back constraint one at a time)

```{r include=TRUE, echo=TRUE, results='hide'}

# Calculate dissatisfaction values based on preferences (higher value indicates higher dissatisfaction)
# Quadratic dissatisfaction values
dissatisfaction_values <- (num_columns - preference_matrix + 1)^2

# Convert dissatisfaction values to a vector for the objective function
objective_coeffs_dissatisfaction <- as.vector(dissatisfaction_values)

# Create an empty LP model for minimizing dissatisfaction
lp_model_dissatisfaction <- make.lp(0, num_doctors * num_terms)

# Set binary decision variables (0 or 1)
set.type(lp_model_dissatisfaction, columns = 1:(num_doctors * num_terms), type = "binary")

# Set the objective function coefficients for minimizing dissatisfaction
set.objfn(lp_model_dissatisfaction, objective_coeffs_dissatisfaction)


## NEXT STEP TO RUN A LOOP TO ASSIGN 5 TERMS ACROSS THE YEAR BASED ON PREFERENCES ##

# Number of times to run the assignment
num_assignments <- 5

# Initialize a list to store the results of each assignment
assignment_results <- list()

# This matrix will have rows corresponding to doctors and columns corresponding to terms.
# An entry of 1 in the matrix indicates that the doctor (row) has been assigned the term (column).
assigned_terms_matrix <- matrix(0, nrow = num_doctors, ncol = num_terms)

# Loop through the assignments
for (assignment_num in 1:num_assignments) {
  # Create an empty LP model for minimizing dissatisfaction
  lp_model_dissatisfaction <- make.lp(0, num_doctors * num_terms)
  
  # Set binary decision variables (0 or 1)
  set.type(lp_model_dissatisfaction, columns = 1:(num_doctors * num_terms), type = "binary")
  
  # Set the objective function coefficients for minimizing dissatisfaction
  set.objfn(lp_model_dissatisfaction, objective_coeffs_dissatisfaction)
  
  # Add constraints to ensure one assignment per doctor
  for (i in 1:num_doctors) {
    constr_one_assignment <- rep(0, num_doctors * num_terms)
    constr_one_assignment[((i - 1) * num_terms + 1):(i * num_terms)] <- 1
    add.constraint(lp_model_dissatisfaction, constr_one_assignment, type = "=", rhs = 1)
  }
  
# 1. Add constraints to limit the maximum number of doctors allocated to each term
  
  # Helper function to retrieve the correct 'max doctors' vector for a given term
  get_max_doctors_for_term <- function(term) {
    switch(term,
           "1" = max_doctors_per_term1,
           "2" = max_doctors_per_term2,
           "3" = max_doctors_per_term3,
           "4" = max_doctors_per_term4,
           "5" = max_doctors_per_term5)
  }
  
  # Add constraints based on the unique requirements of each term
  for (j in 1:num_terms) {
    constr_max_doctors_per_term <- rep(0, num_doctors * num_terms)
    
    # Indices for this term's assignment for all doctors
    indices <- j + seq(0, (num_doctors - 1) * num_terms, by = num_terms)
    constr_max_doctors_per_term[indices] <- 1
    
    # Get the respective 'max doctors' vector for this term
    max_doctors_for_this_term <- get_max_doctors_for_term(assignment_num)
    
    add.constraint(lp_model_dissatisfaction, constr_max_doctors_per_term, type = "<=", rhs = max_doctors_for_this_term[j])
  }
  
  
# 2. Add constraints to prevent doctors from being assigned to the same term again
  for (i in 1:num_doctors) {
    for (j in 1:num_terms) {
      if (assigned_terms_matrix[i, j] == 1) {
        constraint_already_assigned <- rep(0, num_doctors * num_terms)
        constraint_already_assigned[(i - 1) * num_terms + j] <- 1
        add.constraint(lp_model_dissatisfaction, constraint_already_assigned, type = "=", rhs = 0)
      }
    }
  }
  
# 3. Constraints for Specialty Status:
  unique_specialty_statuses <- unique(specialty_status_per_term[!is.na(specialty_status_per_term)])
  
  for (specialty in unique_specialty_statuses) {
    for (i in 1:num_doctors) {
      constr_specialty <- rep(0, num_doctors * num_terms)
      for (j in which(specialty_status_per_term == specialty)) {
        constr_specialty[(i - 1) * num_terms + j] <- 1
      }
      add.constraint(lp_model_dissatisfaction, constr_specialty, type = "<=", rhs = 2)
    }
  }
  
# 4. Constraints for Sub-Specialty Status:
  unique_sub_specialties <- unique(sub_specialty_status_per_term[!is.na(sub_specialty_status_per_term)])
  
  for (sub_specialty in unique_sub_specialties) {
    for (i in 1:num_doctors) {
      constr_sub_specialty <- rep(0, num_doctors * num_terms)
      for (j in which(sub_specialty_status_per_term == sub_specialty)) {
        constr_sub_specialty[(i - 1) * num_terms + j] <- 1
      }
      add.constraint(lp_model_dissatisfaction, constr_sub_specialty, type = "<=", rhs = 1)
    }
  }
  
  # Solve the linear programming problem to minimize dissatisfaction
  lp_result_dissatisfaction <- solve(lp_model_dissatisfaction)
  
  # Check if the LP problem was solved successfully
  if (lp_result_dissatisfaction == 0) {
    optimal_solution_dissatisfaction <- get.variables(lp_model_dissatisfaction)
    assignment_results[[assignment_num]] <- optimal_solution_dissatisfaction
    
    # Update the assigned_terms_matrix based on this solution
    for (i in 1:num_doctors) {
      for (j in 1:num_terms) {
        if (optimal_solution_dissatisfaction[(i - 1) * num_terms + j] == 1) {
          assigned_terms_matrix[i, j] <- 1
        }
      }
    }
  } else {
    cat("LP problem could not be solved for assignment", assignment_num, "Result:", lp_result_dissatisfaction, "\n")
  }
}

# Print the results of each assignment
for (assignment_num in 1:num_assignments) {
  cat("Assignment", assignment_num, "results:\n")
  optimal_solution_dissatisfaction <- assignment_results[[assignment_num]]
  for (i in 1:num_doctors) {
    for (j in 1:num_terms) {
      if (optimal_solution_dissatisfaction[(i - 1) * num_terms + j] == 1) {
        doctor_name <- row_names[i]
        term_name <- column_names[j]
        cat("Doctor", doctor_name, "is assigned to Term", term_name, "\n")
      }
    }
  }
  cat("\n")
}

```



# PGY2 Allocations Output

```{r include=TRUE, echo=TRUE, results='hide'}
# Initialize a data frame to store the results
assignment_table <- data.frame(Doctor = row_names, 
                               Assignment1 = character(num_doctors), 
                               Assignment2 = character(num_doctors),
                               Assignment3 = character(num_doctors),
                               Assignment4 = character(num_doctors),
                               Assignment5 = character(num_doctors),
                               stringsAsFactors = FALSE)

# Populate the data frame with the assignment results
for (assignment_num in 1:num_assignments) {
  optimal_solution_dissatisfaction <- assignment_results[[assignment_num]]
  for (i in 1:num_doctors) {
    for (j in 1:num_terms) {
      if (optimal_solution_dissatisfaction[(i - 1) * num_terms + j] == 1) {
        term_name <- column_names[j]
        assignment_column <- paste0("Assignment", assignment_num)
        assignment_table[i, assignment_column] <- term_name
      }
    }
  }
}

# Sort by the Doctor's first name
assignment_table_sorted <- assignment_table %>%
  arrange(str_extract(Doctor, "^[\\w-]+"))

# Print the table using gt
gt_table <- gt(assignment_table_sorted)
print(gt_table)
```


# MODEL EVALUATION

### This will be used when real data is available to play with quadratic penalties, iterative penalties to the dissatisfaction values in order give higher prioritization to Top 10 preferences over a generally good spread of preferences. 3 working models currently at present.

```{r include=TRUE, echo=TRUE, results='markup'}

# How many Doctors with one Top 10 preference

# Convert the preference matrix into a top 10 boolean matrix
top_10_matrix <- t(apply(preference_matrix, 1, function(row) row %in% sort(row, decreasing = TRUE)[1:10]))

# For each doctor, determine if the assigned terms are in their top 10 preferences
assignment_top_10_matrix <- matrix(0, nrow = num_doctors, ncol = num_assignments)

for (assignment_num in 1:num_assignments) {
  assignment_column <- paste0("Assignment", assignment_num)
  assigned_terms <- assignment_table[, assignment_column]
  
  # Convert the assigned term names back to their column indices
  assigned_indices <- match(assigned_terms, column_names)
  
  for (i in 1:num_doctors) {
    assignment_top_10_matrix[i, assignment_num] <- top_10_matrix[i, assigned_indices[i]]
  }
}

# Sum up for each doctor how many of their assignments are in their top 10
top_10_counts_per_doctor <- rowSums(assignment_top_10_matrix)

# Determine how many doctors got terms in their top 10 preferences for any of the assignments
num_doctors_with_top_10 <- sum(top_10_counts_per_doctor > 0)

cat("Number of doctors with at least one term in their top 10 preferences across all assignments:", num_doctors_with_top_10, "\n")

# Determine how many doctors got at least 2 terms in their top 10 preferences for any of the assignments
num_doctors_with_2_top_10 <- sum(top_10_counts_per_doctor >= 2)

cat("Number of doctors with at least two terms in their top 10 preferences across all assignments:", num_doctors_with_2_top_10, "\n")

# Determine how many doctors got at least 3 terms in their top 10 preferences for any of the assignments
num_doctors_with_3_top_10 <- sum(top_10_counts_per_doctor >= 3)

cat("Number of doctors with at least three terms in their top 10 preferences across all assignments:", num_doctors_with_3_top_10, "\n")



## MODEL EVALUATION - How many doctors with one Top 5 preference ##

# Convert the preference matrix into a top 10 boolean matrix
top_10_matrix <- t(apply(preference_matrix, 1, function(row) row %in% sort(row, decreasing = TRUE)[1:10]))
top_5_matrix <- t(apply(preference_matrix, 1, function(row) row %in% sort(row, decreasing = TRUE)[1:5]))

# Create a function to compute metrics for a given top_x matrix
get_metrics <- function(matrix, assignment_table, column_names, num_assignments) {
  assignment_matrix <- matrix(0, nrow = num_doctors, ncol = num_assignments)
  
  for (assignment_num in 1:num_assignments) {
    assignment_column <- paste0("Assignment", assignment_num)
    assigned_terms <- assignment_table[, assignment_column]
    
    # Convert the assigned term names back to their column indices
    assigned_indices <- match(assigned_terms, column_names)
    
    for (i in 1:num_doctors) {
      assignment_matrix[i, assignment_num] <- matrix[i, assigned_indices[i]]
    }
  }
  
  return(rowSums(assignment_matrix))
}

top_10_counts_per_doctor <- get_metrics(top_10_matrix, assignment_table, column_names, num_assignments)
top_5_counts_per_doctor <- get_metrics(top_5_matrix, assignment_table, column_names, num_assignments)

# Extract all assigned terms for each doctor across the assignments
assigned_terms_all <- as.vector(t(assignment_table[, 2:(num_assignments + 1)]))

# Convert the assigned term names back to their column indices
assigned_indices_all <- match(assigned_terms_all, column_names)

# Retrieve preference values using matrix indexing
assigned_preference_values <- matrix(0, nrow = num_doctors, ncol = num_assignments)
for (assignment_num in 1:num_assignments) {
  assignment_column <- paste0("Assignment", assignment_num)
  assigned_terms <- assignment_table[, assignment_column]
  
  # Convert the assigned term names back to their column indices
  assigned_indices <- match(assigned_terms, column_names)
  
  for (i in 1:num_doctors) {
    assigned_preference_values[i, assignment_num] <- preference_matrix[i, assigned_indices[i]]
  }
}

average_assigned_preference <- mean(as.vector(assigned_preference_values))

# Calculate the metrics of interest for each doctor
range_per_doctor <- apply(assigned_preference_values, 1, range)
max_per_doctor <- range_per_doctor[2,]
min_per_doctor <- range_per_doctor[1,]
sd_per_doctor <- apply(assigned_preference_values, 1, sd)

# Compute the average values across all doctors
average_max = mean(max_per_doctor)
average_min = mean(min_per_doctor)
average_sd = mean(sd_per_doctor)

# Create a data frame with the evaluation metrics
evaluation_data <- data.frame(
  Metric = c("At least 1 term in Top 10 (%)", 
             "At least 2 terms in Top 10 (%)", 
             "At least 3 terms in Top 10 (%)", 
             "At least 1 term in Top 5 (%)",
             "Average Preference of Assigned Terms",
             "Average Max of Assigned Preferences",
             "Average Min of Assigned Preferences",
             "Average SD of Assigned Preferences"),
  Value = c(sum(top_10_counts_per_doctor > 0) / num_doctors * 100, 
            sum(top_10_counts_per_doctor >= 2) / num_doctors * 100, 
            sum(top_10_counts_per_doctor >= 3) / num_doctors * 100, 
            sum(top_5_counts_per_doctor > 0) / num_doctors * 100,
            average_assigned_preference,
            average_max,
            average_min,
            average_sd)
)

# Round the values to 2 decimal places
evaluation_data$Value <- round(evaluation_data$Value, 2)

# Generate the table using gt
evaluation_table <- gt(evaluation_data) %>% 
  tab_header(
    title = "Model Evaluation"
  ) %>% 
  cols_label(
    Metric = "Metric",
    Value = "Value"
  )

# Print the table
evaluation_table
```


                         
# Reporting - 

### To add transparancy to allocations process and to assist in manual auditing of lines in order to preserve the integrity of the preferences of the cohort. Assist with manual changes to make terms HETI compliant or understand GAPS in the event their is nil viable solution to whole gamut of constraints. 

```{r include=TRUE, echo=TRUE, results='markup'}

# 1. Doctors Preference Report

# Initialize an empty data frame to store the report
doctor_preference_report <- data.frame(
  Doctor = character(),
  Term = character(),
  Preference_Score = numeric(),
  stringsAsFactors = FALSE
)

# Iterate through each doctor
for (i in 1:num_doctors) {
  doctor_name <- row_names[i]
  
  # Iterate through each of the assignments to extract the allocated terms for each doctor
  for (assignment_num in 1:num_assignments) {
    optimal_solution_dissatisfaction <- assignment_results[[assignment_num]]
    for (j in 1:num_terms) {
      if (optimal_solution_dissatisfaction[(i - 1) * num_terms + j] == 1) {
        assigned_term <- column_names[j]
        
        # Access the doctor's preference row from the preference matrix
        doctor_preference <- preference_matrix[i, ]
        
        # Calculate preference score for the assigned term
        preference_score <- doctor_preference[match(assigned_term, column_names)]
        
        # Build a data frame with the results for this doctor and term
        doctor_report <- data.frame(
          Doctor = rep(doctor_name, 1),
          Term = assigned_term,
          Preference_Score = preference_score
        )
        
        # Append the doctor's report to the overall report data frame
        doctor_preference_report <- rbind(doctor_preference_report, doctor_report)
      }
    }
  }
}

# Sort by the Doctor's first name
doctor_preference_report_sorted <- doctor_preference_report %>%
  arrange(str_extract(Doctor, "^[\\w-]+"))

# Print the report using gt
doctor_preference_report_table <- gt(doctor_preference_report_sorted)
print(doctor_preference_report_table)



# 2. HETI Compliance Report


# Calculate average preference for each doctor across all 5 assignments
avg_preference <- doctor_preference_report %>%
  group_by(Doctor) %>%
  summarize(Avg_Score = mean(Preference_Score, na.rm = TRUE))

# Check if a doctor has been assigned to more than 1 term in any sub-specialty
sub_specialty_compliance <- sapply(1:num_doctors, function(i) {
  doctor_name <- row_names[i]
  assigned_terms_df <- subset(doctor_preference_report, Doctor == doctor_name)
  terms_assigned <- assigned_terms_df$Term
  sub_specialty_terms <- sub_specialty_status_per_term[terms_assigned]
  max_count <- max(table(sub_specialty_terms), na.rm = TRUE)
  return(max_count <= 1)
})

# Check if a doctor has been assigned to more than 2 terms in any specialty
specialty_compliance <- sapply(1:num_doctors, function(i) {
  doctor_name <- row_names[i]
  terms_assigned <- doctor_preference_report$Term[doctor_preference_report$Doctor == doctor_name]
  specialty_terms <- specialty_status_per_term[terms_assigned]
  max_count <- max(table(specialty_terms), na.rm = TRUE)
  return(max_count <= 2)
})

# Check if a doctor has been assigned to at least 3 "Team Based" terms
team_based_compliance <- sapply(1:num_doctors, function(i) {
  doctor_name <- row_names[i]
  terms_assigned <- doctor_preference_report$Term[doctor_preference_report$Doctor == doctor_name]
  
  # Debugging print statements
  print(paste("Doctor:", doctor_name))
  print(paste("Assigned terms:", toString(terms_assigned)))
  structure_indices <- match(terms_assigned, names(clinical_structure_term))
  print(paste("Matching indices:", toString(structure_indices)))
  print(paste("Clinical structures:", toString(clinical_structure_term[structure_indices])))
  
  team_based_count <- sum(clinical_structure_term[structure_indices] == "Team Based")
  
  return(team_based_count >= 3)
})

# Check for compliance with the desired term classifications
check_term_classifications <- function(terms_assigned) {
  classification1 <- term_classification1[match(terms_assigned, column_names)]
  classification2 <- term_classification2[match(terms_assigned, column_names)]
  required_terms <- c("A-Undifferentiated illness patient care", 
                      "B-Chronic illness patient care", 
                      "C-Acute critical illness patient care")
  
  # Check for each term individually, without merging the classifications
  has_required_terms <- sapply(required_terms, function(term) {
    term %in% classification1 || term %in% classification2
  })
  
  return(all(has_required_terms))
}

term_classifications_compliance <- sapply(1:num_doctors, function(i) {
  doctor_name <- row_names[i]
  terms_assigned <- doctor_preference_report$Term[doctor_preference_report$Doctor == doctor_name]
  return(check_term_classifications(terms_assigned))
})

compliance_data <- data.frame(
  Doctor = avg_preference$Doctor,
  Avg_Preference = avg_preference$Avg_Score,
  SubSpecialty_Compliance = sub_specialty_compliance,
  Specialty_Compliance = specialty_compliance,
  Team_Based_Compliance = team_based_compliance,
  Term_Classifications_Compliance = term_classifications_compliance
)

# Format with gt

HETI_compliance_table <- compliance_data %>%
  gt() %>%
  cols_label(
    Avg_Preference = "Avg. Preference (1-5)",
    SubSpecialty_Compliance = "Max 1 Term in Sub-Specialty",
    Specialty_Compliance = "Max 2 Terms in Specialty",
    Team_Based_Compliance = "At Least 3 'Team Based' Terms",
    Term_Classifications_Compliance = "Essential Classifications"
  )

print(HETI_compliance_table)
```



*This code, inclusive of all associated documentation and related content, is the exclusive intellectual property of Dr. Scott Johnson Gelzinnis under the Copyright Act 1968 (Cth) of Australia. Any unauthorized use, reproduction, distribution, or modification of this material, in entirety or in parts, without the prior written consent of Dr. Scott Johnson Gelzinnis, may constitute a breach of Australian copyright laws and can result in legal action.*
